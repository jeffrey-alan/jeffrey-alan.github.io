<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker入门介绍</title>
    <url>/2019/12/17/Docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比传统虚拟机技术更为轻便、快捷Docker。</p>
<h1 id="Docker-VS-Visual-Machine"><a href="#Docker-VS-Visual-Machine" class="headerlink" title="Docker VS Visual Machine"></a>Docker VS Visual Machine</h1><h2 id="Visual-Machine"><a href="#Visual-Machine" class="headerlink" title="Visual Machine"></a>Visual Machine</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器比传统虚拟机更轻便。</p>
<h1 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h1><ul>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>较弱</td>
</tr>
<tr>
<td>系统支持量</td>
<td>上千个</td>
<td>几十个</td>
</tr>
</tbody></table>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p><img src="http://tc.llx-cn.com/20191217131541.png" alt="20191217131541"></p>
<p>Docker 使用CS架构模式，使用远程API来管理和创建Docker容器。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker 包括三个基本概念（镜像、容器、仓库），理解了这三个概念，就理解了Docker的整个生命周期。</p>
<h2 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h2><p>我们都知道，操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载文件系统为其提供用户空间支持。而 Docker 镜像，相当于是一个 root 文件系统。</p>
<p>比如官方镜像 centos:7.6 就包含了完整的一套 centos 7.6最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置和参数（匿名卷、环境变量、用户等）。</p>
<p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="镜像分层存储"><a href="#镜像分层存储" class="headerlink" title="镜像分层存储"></a>镜像分层存储</h3><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时将其设计为分层存储的架构。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完成就不会再发生改变，后一层上的任何改变只发生在自己这一层。在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还是得镜像的附庸、定制变得更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h2 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h2><p>镜像和容器的关系，就像 Java 中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>
<p>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随着容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume 数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据不会丢失。</p>
<h2 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中存储、分发镜像的服务，Docker Registry 就是这个的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；<br>每个仓库可以包含多个标签（Tag）；<br>每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p>以cengos 镜像为例，cengos 是仓库名称，其内包含不同的版本标签，如6.9、7.5。我们可以通过 cengos:6.9 或者 centos:7.5 来具体指定所需哪个版本的镜像。如果忽略标签，比如 centos,那就将视为 centos:latest。</p>
<p>仓库名经常以两段式路径形式出现，比如 study/nginx，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="Registry-公开仓库"><a href="#Registry-公开仓库" class="headerlink" title="Registry 公开仓库"></a>Registry 公开仓库</h3><p>常用的Registry 是官方的 Docker Hub，也就是默认的Registry。除此之外，还有CentOS的Quay.io，Centos 相关的镜像存储在这里。Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。</p>
<p>国内的一些云服务商提供了针对 Docker Hub 的镜像服务，这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从Docker Hub 下载速度会提高很多。</p>
<p>国内也有一些云提供商提供类似于 Docker Hub 的公开服务。比如网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。</p>
<h3 id="Registry-私有仓库"><a href="#Registry-私有仓库" class="headerlink" title="Registry 私有仓库"></a>Registry 私有仓库</h3><p>除了使用公开服务外，用户还可以搭建本地私有 Docker Registry。官方还提供了 Docker Registry 镜像，可以直接使用作为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面及一些高级功能。比如VMware Harbor 和 Sonatype Nexus。</p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>版本格式</td>
<td>YY.MM</td>
</tr>
<tr>
<td>Stable 版本</td>
<td>每个季度发行</td>
</tr>
<tr>
<td>Edge 版本</td>
<td>每个月发行</td>
</tr>
<tr>
<td>当前 Docker CE Stable 版本</td>
<td>18.09</td>
</tr>
<tr>
<td>当前 Docker CE Edge 版本</td>
<td>18.09</td>
</tr>
</tbody></table>
<p>同时 Docker 划分为以下两个版本。</p>
<p>社区版（CE）：免费，支持周期三个月<br>企业版（EE）：强调安全，付费使用</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看内核版本，不能低于3.10 </span></pre></td></tr><tr><td class="code"><pre><span class="line">uname -r</span></pre></td></tr></table></figure>

<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 旧版本的Docker 称为 docker 或者 docker-engine</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo yum remove docker docker-common docker-selinux docker-engine</span></pre></td></tr></table></figure>

<h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装依赖</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加yum源</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始安装</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo yum install -y docker-ce</span></pre></td></tr></table></figure>

<h3 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载脚本</span></pre></td></tr><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com -o get-docker.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开始一键安装</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo sh get-docker.sh --mirror Aliyun</span></pre></td></tr></table></figure>

<h3 id="启动Docker-CE"><a href="#启动Docker-CE" class="headerlink" title="启动Docker CE"></a>启动Docker CE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置开机启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 开启服务</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span></pre></td></tr></table></figure>

<h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root用户和docker组的用户才可以访问 Docker 引擎的 Unix socket。</p>
<p>一般 Linux 系统上不会直接使用root用户进行操作。因此需要将使用docker的用户加入到docker用户组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 建立 docker 组</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo groupadd docker</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将当前用户加入docker组</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span></pre></td></tr></table></figure>
<h3 id="检测是否安装正确"><a href="#检测是否安装正确" class="headerlink" title="检测是否安装正确"></a>检测是否安装正确</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动一个基于hello-world镜像的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run hello-world</span></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h3 id="删除安装包"><a href="#删除安装包" class="headerlink" title="删除安装包"></a>删除安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sodu yum remove docker-ce</span></pre></td></tr></table></figure>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span></pre></td></tr></table></figure>

<h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。</p>
<ul>
<li>Docker 官方提供的中国 Registry Mirror</li>
<li>阿里云加速器</li>
<li>DaoCloud加速器</li>
<li>163加速器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">vi &#x2F;&#x2F;etc&#x2F;docket&#x2F;daemon.json</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 填写内容</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &quot;registry-mirrors&quot;:[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;http:&#x2F;&#x2F;hub.mirror.c.163.com&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>重新启动服务生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; daemon 生效</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; docker 重启生效</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker info</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 看到配置完成的信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">Registry Mirrors: http:&#x2F;&#x2F;hub-mirror.c.163.com</span></pre></td></tr></table></figure>

<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h2 id="从仓库获取镜像"><a href="#从仓库获取镜像" class="headerlink" title="从仓库获取镜像"></a>从仓库获取镜像</h2><p>从Docker镜像仓库获取镜像的命令是：docker pull</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 具体选项帮助</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull --help</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号&#x2F;]]仓库名[:标签]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认从官方 library&#x2F;ubuntu 仓库中获取标签为16.04的镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span></pre></td></tr></table></figure>

<p>镜像仓库地址：&lt;域名/IP&gt;[:端口号]<br>仓库名称：&lt;用户名称&gt;/&lt;软件名称&gt;</p>
<p>官方仓库地址：Docker Hub<br>官方镜像：library</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; -it：终端交互操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; --rm： 容器退出后随之将其删除</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bash： 交互式的shell</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -it --rm  ubuntu:16.04 bash</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 退出容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">exit</span></pre></td></tr></table></figure>

<h2 id="管理本地主机上的镜像"><a href="#管理本地主机上的镜像" class="headerlink" title="管理本地主机上的镜像"></a>管理本地主机上的镜像</h2><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看镜像列表，包含仓库名、标签、镜像ID、创建时间、占用空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image ls</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看镜像、容器、数据卷占用空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker system df</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 仓库名、标签均为 &lt;none&gt;的镜像称为虚悬镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看虚悬镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image ls -f dangling&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除虚悬镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image prune</span></pre></td></tr></table></figure>

<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 镜像可以是短ID、长ID、名称、摘要</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除所有仓库名为ubuntu的镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image rm $(docker image ls -q ubuntu)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除ubuntu:16.04 以前的镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image rm $(docker image ls -q -f before&#x3D;ubuntu:16.04)</span></pre></td></tr></table></figure>



<h2 id="介绍镜像实现的基本原理"><a href="#介绍镜像实现的基本原理" class="headerlink" title="介绍镜像实现的基本原理"></a>介绍镜像实现的基本原理</h2><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。相应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其它系统环境）和跑在上面的应用。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，</p>
<ul>
<li>基于镜像新建一个容器并启动</li>
<li>将在终止状态的容器重新启动</li>
</ul>
<p>因为Docker 的容器是轻量级的，用户可以随时删除和创建容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run</span></pre></td></tr></table></figure>

<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一：启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker container start</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式二：启动</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker start</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动一个bash终端，允许用户进行交互</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; -t 分配一个伪终端并绑定到容器的标准输入上</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; -i 让容器的标准输入保持打开</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:16:04 &#x2F;bin&#x2F;bash</span></pre></td></tr></table></figure>
<p>当利用docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个IP地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>docker run ubuntu:16.04 /bin/echo ‘hello World’</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>很多时候，需要让Docker 在后台运行而不是直接把执行命令的结构输出在当前宿主机下。此时，可以通过 -d 参数 来实现。</p>
<p>如果不使用 -d 参数 运行容器，比如 docker run hello-world 会把日志打印在控制台。<br>如果使用率 -d 参数 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行容器，加上参数 -d ，不会输出日志，智慧打印容器ID，输出结果可以去 docker logs查看</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -d hello-world</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">docker run -it ubuntu:16:04 &#x2F;bin&#x2F;bash</span></pre></td></tr></table></figure>

<h3 id="停止运行的容器"><a href="#停止运行的容器" class="headerlink" title="停止运行的容器"></a>停止运行的容器</h3><p>// 容器终止<br>docker container stop 容器ID</p>
<p>// 查看终止状态的容器<br>docker container ls -a</p>
<p>// 容器启动<br>docker container start 容器ID</p>
<p>// 容器重启<br>docker container restart 容器ID</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID &#x2F;bin&#x2F;bash</span></pre></td></tr></table></figure>


<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出本地某个容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker export 容器ID &gt; 导出文件名.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat 导出文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 也可以通过制定URL 或者某个目录来导入</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker import http:&#x2F;&#x2F;study.163.com&#x2F;image.tgz example&#x2F;imagerepo</span></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除容器， -f 表示删除一个运行中的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker container rm ubuntu:16:04</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看已经</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker container ls -a </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除掉处于终止状态的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker container prune</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器化技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门介绍</title>
    <url>/2019/12/16/Nginx%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><p>Nginx 作为一个强大的Web服务器软件，具有高性能、高并发性和低内存占用的特点。此外，其也能提供强大的反向代理功能。根据 Netcraft 公司统计，世界上最繁忙的网站中有 11.48%使用 Nginx 作为其服务器或者代理服务器。</p>
<a id="more"></a>

<p>Nginx 由俄罗斯的程序设计师 lgor Sysoev（伊戈尔·赛索耶夫） 所开发，最初供俄罗斯大型的入口网站及搜索引擎 Rambler 使用。其特点是占用内存少，并发能力强（用于解决 C10K 问题），事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。</p>
<p>俄罗斯大约有超过20%的虚拟主机采用Nginx作为反向代理服务器。<br>中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p><img src="http://tc.llx-cn.com/20191216162951.png" alt="20191216162951"></p>
<p>基于反向代理的功能，Nginx 作为负载均衡主要有一下几个特点：</p>
<ul>
<li><strong>高性能</strong>：采用C语言直接开发，编译的形式部署</li>
<li><strong>高并发</strong>：采用 epoll NIO，效率非常高</li>
<li><strong>低内存</strong>：数据结构紧凑、零拷贝</li>
<li>配置简单</li>
<li>成本低廉</li>
<li>支持 Rewrite 重写规则</li>
<li>内置健康检查功能</li>
<li>节省带宽</li>
<li>稳定性高</li>
</ul>
<p>其他同类Web服务</p>
<ul>
<li><strong>Apache</strong>： Apache HTTP 服务器是一个模块化的服务器，可以运行在几乎所有广泛使用的计算机平台上。其属于应用服务器。Apache支持支持模块多，性能稳定，Apache本身是静态解析，适合静态HTML、图片等，但可以通过扩展脚本、模块等支持动态页面等。 （Apche可以支持PHPcgiperl,但是要使用Java的话，你需要Tomcat在Apache后台支撑，将Java请求由Apache转发给Tomcat处理。） 缺点：配置相对复杂，自身不支持动态页面。</li>
<li><strong>Tomcat</strong>： Tomcat是应用（Java）服务器，它只是一个Servlet(JSP也翻译成Servlet)容器，可以认为是Apache的扩展，但是可以独立于Apache运行。</li>
</ul>
<h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>类似于一个跳板机，通过代理访问外部资源</p>
<p><img src="http://tc.llx-cn.com/20191216161032.png" alt="20191216161032"></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>实际运行方式是指代理服务器来接收 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求的客户端，此时代理服务器对外就表现为一台服务器。</p>
<p><img src="http://tc.llx-cn.com/20191216161054.png" alt="20191216161054"></p>
<h2 id="反向代理作用"><a href="#反向代理作用" class="headerlink" title="反向代理作用"></a>反向代理作用</h2><ul>
<li>保证内网安全：可以使用反向代理提供的WAF功能，阻止web攻击。大型网站，通常将反向代理提供给公网访问，而真正的Web服务则是部署在内网中。</li>
<li>负载均衡：通过反向代理来优化网站的负载。</li>
</ul>
<p><img src="http://tc.llx-cn.com/20191216161106.png" alt="20191216161106"></p>
<h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><h2 id="Round-Robin-（轮询）"><a href="#Round-Robin-（轮询）" class="headerlink" title="Round Robin （轮询）"></a>Round Robin （轮询）</h2><p>最基本的配置就是轮询的方式。根据Nginx配置文件中的顺序，依次将请求分配到不同的后端服务器上。</p>
<ul>
<li>缺省配置就是轮询策略。</li>
<li>nginx负载均衡支持http和https协议，只需要修改 proxy_pass 后协议即可。</li>
<li>nginx支持FastCGI、uwsgi、SCGI、memcached的负载均衡，只需要将proxy_pass 改为 fastcgi_pass，uwsgi_pass、scgi_pass、memcached_pass即可</li>
<li>此策略适合服务器配置相当，无状态并且短平快的服务使用</li>
<li>如果服务器down掉了，会自动剔除服务器。</li>
</ul>
<h2 id="weight（权重）"><a href="#weight（权重）" class="headerlink" title="weight（权重）"></a>weight（权重）</h2><p>基于权重的负载均衡（Weighted Load Balancing），这种方式下，我们可以配置Nginx 把请求更多地分发到高配置的后端服务器，把相对较少的请求分发到低配置服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#动态服务器组</span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream netbase.com &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8080  weight&#x3D;2; #tomcat 7.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8081; #tomcat 8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8082  backup; #tomcat 8.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8083  max_fails&#x3D;3 fail_timeout&#x3D;20s; #tomcat 9.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在该例子中，weight参数用于指定轮询几率，weight的默认值为1,；weight的数值与访问比率成正比，比如Tomcat 7.0被访问的几率为其他服务器的两倍。</p>
<ul>
<li>权重越高分配到需要处理的请求越多。</li>
<li>此策略可以与 least_conn 和 ip_hash 结合使用。</li>
<li>此策略比较适合服务器的硬件配置差别比较大的情况</li>
</ul>
<h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。</p>
<p>这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#动态服务器组</span></pre></td></tr><tr><td class="code"><pre><span class="line">  upstream netbase.com &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ip_hash;  #保证每个访客固定访问一个后端服务器</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server localhost:8080  weight&#x3D;2; #tomcat 7.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server localhost:8081;               #tomcat 8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server localhost:8082;              #tomcat 8.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server localhost:8083  max_fails&#x3D;3 fail_timeout&#x3D;20s; #tomcat 9.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。</li>
<li>ip_hash不能与backup同时使用。</li>
<li>此策略适合有状态服务，比如session。</li>
<li>当有服务器需要剔除，必须手动down掉。</li>
</ul>
<h2 id="least-conn（最少连接）"><a href="#least-conn（最少连接）" class="headerlink" title="least_conn（最少连接）"></a>least_conn（最少连接）</h2><p>把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；</p>
<p>但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#动态服务器组</span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream netbase.com &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  least_conn;  #把请求转发给连接数较少的后端服务器</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8080  weight&#x3D;2;   #tomcat 7.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8081;                 #tomcat 8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8082 backup;      #tomcat 8.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8083  max_fails&#x3D;3 fail_timeout&#x3D;20s; #tomcat 9.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p>
<h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#动态服务器组</span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream netbase.com &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8080; #tomcat 7.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8081; #tomcat 8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8082; #tomcat 8.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8083; #tomcat 9.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  fair;  #实现响应时间短的优先分配</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按照访问 url 的 hash 结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。</p>
<p>同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。</p>
<p>而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#动态服务器组</span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream dynamic_zuoyu &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  hash $request_uri;  #实现每个url定向到同一个后端服务器</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8080; #tomcat 7.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8081; #tomcat 8.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8082; #tomcat 8.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">  server localhost:8083; #tomcat 9.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h1 id="代理缓存机制"><a href="#代理缓存机制" class="headerlink" title="代理缓存机制"></a>代理缓存机制</h1><p>nginx的http_proxy模块，可以实现类似于Squild的缓存功能</p>
<p>nginx对客户已经访问过的内容在nginx服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过nginx服务器再次向后端服务器发出请求，所以能够减少nginx服务器与后端服务器之间的网络流量，减轻网络拥塞，同时还能减小数据传输延迟，提高用户访问速度。</p>
<p>同时，当后端服务器宕机时，nginx服务器上的副本资源还能够回应相关的用户请求，这样能够提高后端服务器的鲁棒性（健壮性）。</p>
<p><img src="http://tc.llx-cn.com/20191216161153.png" alt="20191216161153"></p>
<h2 id="缓存文件放哪里？"><a href="#缓存文件放哪里？" class="headerlink" title="缓存文件放哪里？"></a>缓存文件放哪里？</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_path</td>
<td>使用该参数指定缓存位置</td>
</tr>
<tr>
<td>proxy_cache</td>
<td>该参数为之前指定的缓存名称</td>
</tr>
</tbody></table>
<p>proxy_cache_path 有两个必填参数：</p>
<p>第一个参数：缓存目录<br>第二个参数：keys_zone指定缓存名称和占用内存空间的大小</p>
<p>注意：下面示例中的10m是对内存中缓存内容元数据信息大小的限值，如果想限值缓存总量大小，需要用max_size参数</p>
<h2 id="如何指定哪些请求被缓存？"><a href="#如何指定哪些请求被缓存？" class="headerlink" title="如何指定哪些请求被缓存？"></a>如何指定哪些请求被缓存？</h2><ul>
<li>nginx默认会缓存所有get和head方法的请求结果，缓存的key默认使用请求字符串。</li>
<li>自定义key：例如proxy_cache_key hosthostrequest_uri$cookie_user</li>
<li>指定请求至少被发送了多少次以上时才缓存，可以防止低频请求被缓存例如 proxy_cache_min_uses 5</li>
<li>指定哪些方法的请求被缓存：例如proxy_cache_methods GET HEAD POST</li>
</ul>
<h2 id="缓存的有效期是多久？"><a href="#缓存的有效期是多久？" class="headerlink" title="缓存的有效期是多久？"></a>缓存的有效期是多久？</h2><p>默认情况下，缓存内容长期留存，除法缓存的总量超出限制。可以指定缓存有效时间，例如：<br>//响应状态码为200 302时，10分钟有效<br>proxy_cache_valid 200 302 10m<br>//对应任何状态码，5分钟有效<br>proxy_cache_valid any 5m</p>
<h2 id="对于某些请求是否可以不走缓存？"><a href="#对于某些请求是否可以不走缓存？" class="headerlink" title="对于某些请求是否可以不走缓存？"></a>对于某些请求是否可以不走缓存？</h2><p>proxy_cache_bypass：该指令响应来自原始服务器而不是缓存</p>
<p>//如果任何一个参数值不为空，或者不等于0，nginx就不会查找缓存，直接进行代理转发<br>proxy_cache_bypass cookienocachecookienocachearg_nocache $arg_comment</p>
<p>网页的缓存是由HTTP消息头“Cache-control”来控制的，常见的取值有public、private、no-cache、max-age、must-revalidate等，默认为private。其作用根据不同的重新浏览方式分为下面几种情况。</p>
<h1 id="通过Lua扩展Nginx"><a href="#通过Lua扩展Nginx" class="headerlink" title="通过Lua扩展Nginx"></a>通过Lua扩展Nginx</h1><p>nginx模块需要用C开发，而且必须符合一系列复杂的规则，用C开发模块必须熟悉nginx的源代码，使得开发者望而生畏。</p>
<p>ngx_lua模块通过将lua解释器集成进nginx，可以采用lua脚本实现业务逻辑。</p>
<p>该模块具备以下特性：</p>
<ul>
<li><strong>高并发、非阻塞的处理各种请求</strong></li>
<li><strong>Lua内建协程，可以很好的将异步回调转换成顺序调用的形式</strong></li>
<li><strong>每个协程都有一个独立的全局环境（变量空间），继承全局共享的、只读的comman data</strong></li>
</ul>
<p>得益于Lua协程的支持，ngx_lua在处理10000个并发请求时只需要很少的内存，非常适合用于实现可扩展的、高并发的服务。</p>
<p>协程（Coroutine）  进程是资源分配的基本单位，线程是资源调度的基本单位。</p>
<p>协程类似一种多线程，与多线程的区别有：</p>
<ol>
<li><strong>协程并发os线程，所以创建、切换开销比线程相对要小。</strong></li>
<li><strong>协程与线程一样有自己的栈、局部变量等，但是协程的栈是在用户进程空间模拟的，所以创建、切换开销很小。</strong></li>
<li><strong>多线程程序是多个线程并发执行，也就是说在一瞬间有多个控制流在执行。而协程强调的是一种多个协程键协作的关系，只有当一个协程主动放弃执行权，另一个协程才能获得执行权，所以在某一瞬间，多个协程间只有一个在运行。</strong></li>
<li><strong>由于多个协程只有一个在运行，所以对于临界区的访问不需要加锁，而多线程的情况则必须加锁。</strong></li>
<li><strong>多线程程序由于有多个控制流，所以程序的行为不可控，而多个协程的执行是由开发者定义的所以是可控的。</strong></li>
</ol>
<p>nginx的每个Worker进程都是在epoll或kqueue这样的事件模型上，封装成协程，每个请求都有一个协程进行处理。这正好与Lua内建协程的模型是一致的，所以即使ngx_lua需要执行Lua，相对C有一定的开销，但依然能保证高并发能力。</p>
<h2 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h2><p>nginx采用多进程模型，单Master-多Worker，Master进程主要用了管理Worker进程。</p>
<p>Worker进程采用单线程、非阻塞的事件模型（Event Loop，事件循环）来实现端口的监听及客户端请求的处理和响应，同时Worker还要处理来自Master的信号。Worker进程个数一般设置为机器CPU核数。 </p>
<p>Master进程具体包括如下4个主要功能：</p>
<p>Master进程具体包括如下4个主要功能：</p>
<ul>
<li>接收来自外界的信号</li>
<li>向各worker进程发送信号</li>
<li>监控worker进程的运行状态</li>
<li>当worker进程退出后（异常情况下），会自动重新启动新的worker进程</li>
</ul>
<p><img src="http://tc.llx-cn.com/20191216161217.png" alt="20191216161217"></p>
<h2 id="ngx-lua指令"><a href="#ngx-lua指令" class="headerlink" title="ngx_lua指令"></a>ngx_lua指令</h2><p>属于nginx的一部分，它的执行指令都包含在nginx的11个步骤中，相应的处理阶段可以做插入式处理，即可插拔式架构，不过ngx_lua并不是所有阶段都会运行的；</p>
<p>另外指令可以在http、server if、location、location if几个范围进行配置：</p>
<h2 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h2><p>是一个基于nginx与Lua的高性能Web平台，其内部集成了大量精良的Lua库、第三方模块，以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。</p>
<p><strong>工作原理</strong>：通过汇聚各种设计精良的nginx模块，从而将nginx有效地变成一个强大的通用Web应用平台。这样，Web开发人员和系统工程师可以使用Lua脚本语言调动nginx支持的各种C以及Lua模块，快速构造出足以胜任10K乃至1000K以上单机并发连接的高性能Web应用系统。</p>
<p><strong>目标</strong>：让你的Web服务直接跑在nginx服务内部，充分利用nginx的非阻塞I/O模型，不仅仅对HTTP客户端请求，甚至对于远程后端诸如MySQL、PostgreSQL、Memcached以及Redis等都进行一致的高性能响应。</p>
<ul>
<li>OpenResty是个package，打包了nginx和各种精良的库</li>
<li>将简单的转发工作，扩充为可以编写动态脚本</li>
<li>nginx转变为业务服务器，可以进行增删改查，可以进行业务处理</li>
</ul>
<p>content_by_lua：内容处理器，接收请求处理并输出响应。</p>
<p>该指令工作在nginx处理流程的content阶段，即内容生产阶段，是所有请求处理阶段中最为重要的阶段，因为这个阶段的指令通常是用来生成HTTP响应内容的</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>负载均衡中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT入门介绍</title>
    <url>/2019/12/11/MQTT%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。</p>
<a id="more"></a>

<p>MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<p><img src="http://tc.llx-cn.com/20191211162544.png" alt="20191211162544"></p>
<h1 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h1><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p>
<ul>
<li>精简，不添加可有可无的功能；</li>
<li>发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li>
<li>允许用户动态创建主题，零运维成本；</li>
<li>把传输量降到最低以提高传输效率；</li>
<li>把低带宽、高延迟、不稳定的网络等因素考虑在内；</li>
<li>支持连续的会话控制；</li>
<li>理解客户端计算能力可能很低；</li>
<li>提供服务质量管理；</li>
<li>假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<h1 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h1><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p>
<ul>
<li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</li>
<li>对负载内容屏蔽的消息传输。</li>
<li>使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</li>
<li>有三种消息发布服务质量：”至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。”至少一次”，确保消息到达，但消息重复可能会发生。”只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</li>
<li>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</li>
<li>使用Last Will和Testament特性通知有关各方客户端异常中断的机制。Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。Testament：遗嘱机制，功能类似于Last Will。</li>
</ul>
<h1 id="MQTT协议原理"><a href="#MQTT协议原理" class="headerlink" title="MQTT协议原理"></a>MQTT协议原理</h1><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li>
<li>payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h2 id="MQTT协议实现方式"><a href="#MQTT协议实现方式" class="headerlink" title="MQTT协议实现方式"></a>MQTT协议实现方式</h2><h2 id="网络传输与应用消息"><a href="#网络传输与应用消息" class="headerlink" title="网络传输与应用消息"></a>网络传输与应用消息</h2><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h2 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h2><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ol>
<li>发布其他客户端可能会订阅的信息；</li>
<li>订阅其它客户端发布的消息；</li>
<li>退订或删除应用程序的消息；</li>
<li>断开与服务器连接。</li>
</ol>
<h2 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h2><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>接受来自客户的网络连接；</li>
<li>接受客户发布的应用信息；</li>
<li>处理来自客户端的订阅和退订请求；</li>
<li>向订阅的客户转发应用程序消息。</li>
</ul>
<h2 id="MQTT协议中的订阅、主题、会话"><a href="#MQTT协议中的订阅、主题、会话" class="headerlink" title="MQTT协议中的订阅、主题、会话"></a>MQTT协议中的订阅、主题、会话</h2><ul>
<li>订阅（Subscription）订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</li>
<li>会话（Session）每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</li>
<li>主题名（Topic Name）连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</li>
<li>主题筛选器（Topic Filter）一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</li>
<li>负载（Payload）消息订阅者所具体接收的内容。</li>
</ul>
<h2 id="MQTT协议中的方法"><a href="#MQTT协议中的方法" class="headerlink" title="MQTT协议中的方法"></a>MQTT协议中的方法</h2><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ol>
<li>Connect。等待与服务器建立连接。</li>
<li>Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>Subscribe。等待完成订阅。</li>
<li>UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ol>
<h1 id="MQTT协议数据包结构"><a href="#MQTT协议数据包结构" class="headerlink" title="MQTT协议数据包结构"></a>MQTT协议数据包结构</h1><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p>
<p>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。<br>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。<br>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</p>
<h2 id="MQTT固定头"><a href="#MQTT固定头" class="headerlink" title="MQTT固定头"></a>MQTT固定头</h2><p>固定头存在于所有MQTT数据包中，其结构如下：</p>
<h3 id="MQTT数据包类型"><a href="#MQTT数据包类型" class="headerlink" title="MQTT数据包类型"></a>MQTT数据包类型</h3><p>位置：Byte 1中bits 7-4。<br>相于一个4位的无符号值，类型、取值及描述如下：</p>
<h3 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h3><p>位置：Byte 1中bits 3-0。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<ul>
<li>DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</li>
<li>QoS：发布消息的服务质量，即：保证消息传递的次数</li>
<li>RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）</li>
</ul>
<h2 id="MQTT可变头"><a href="#MQTT可变头" class="headerlink" title="MQTT可变头"></a>MQTT可变头</h2><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<h2 id="Payload消息体"><a href="#Payload消息体" class="headerlink" title="Payload消息体"></a>Payload消息体</h2><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE 四种类型的消息：</p>
<ul>
<li>CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li>
<li>SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li>
<li>SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li>
<li>UNSUBSCRIBE，消息体内容是要订阅的主题。</li>
</ul>
]]></content>
      <categories>
        <category>MQTT</category>
        <category>协议</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用总结</title>
    <url>/2019/12/09/Hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>关于hexo的一些使用方法总结</p>
<a id="more"></a>


<h1 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo init blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">cd blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm install</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo server</span></pre></td></tr></table></figure>

<h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span></pre></td></tr></table></figure>

<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span></pre></td></tr></table></figure>

<h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span></pre></td></tr></table></figure>

<h2 id="设置Scheme"><a href="#设置Scheme" class="headerlink" title="设置Scheme"></a>设置Scheme</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> scheme: Muse    # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Mist     # Muse 的紧凑版本，整洁有序的单栏外观</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Pisces  # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span></pre></td></tr><tr><td class="code"><pre><span class="line"># scheme: Gemini  # 类似 Pisces</span></pre></td></tr></table></figure>

<h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 菜单示例配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">menu:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  home: &#x2F; || home</span></pre></td></tr><tr><td class="code"><pre><span class="line">  reading: &#x2F;reading&#x2F; || book</span></pre></td></tr><tr><td class="code"><pre><span class="line">  archives: &#x2F;archives&#x2F; || archive</span></pre></td></tr><tr><td class="code"><pre><span class="line">  categories: &#x2F;categories&#x2F; || th</span></pre></td></tr><tr><td class="code"><pre><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span></pre></td></tr><tr><td class="code"><pre><span class="line">  about: &#x2F;about&#x2F; || user</span></pre></td></tr></table></figure>

<h2 id="音乐插件"><a href="#音乐插件" class="headerlink" title="音乐插件"></a>音乐插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网易云音乐插件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &lt;div id&#x3D;&quot;music163player&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;280 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;26090155&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;iframe&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;div&gt;</span></pre></td></tr></table></figure>
<h2 id="文章预览"><a href="#文章预览" class="headerlink" title="文章预览"></a>文章预览</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommand.</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto_excerpt:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  enable: false</span></pre></td></tr><tr><td class="code"><pre><span class="line">  length: 150</span></pre></td></tr></table></figure>



<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将头像放置主题目录下的 source&#x2F;uploads&#x2F; （新建uploads目录若不存在） 配置为：</span></pre></td></tr><tr><td class="code"><pre><span class="line">avatar: &#x2F;uploads&#x2F;avatar.png</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 放置在 source&#x2F;images&#x2F; 目录下, 配置为：</span></pre></td></tr><tr><td class="code"><pre><span class="line">avatar: &#x2F;images&#x2F;avatar.png</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 完整的互联网 URI</span></pre></td></tr><tr><td class="code"><pre><span class="line">avatar: </span></pre></td></tr><tr><td class="code"><pre><span class="line">   url: http:&#x2F;&#x2F;example.com&#x2F;avatar.png</span></pre></td></tr></table></figure>


<h2 id="头像旋转特效"><a href="#头像旋转特效" class="headerlink" title="头像旋转特效"></a>头像旋转特效</h2><p>themes\next\source\css_common\components\sidebar\sidebar-author.styl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  margin: 0 auto;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  padding: $site-author-image-padding;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  max-width: $site-author-image-width;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  height: $site-author-image-height;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  border-radius: 50%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -webkit-border-radius: 50%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  -moz-border-radius: 50%;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  transition: 1.4s all;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.site-author-image:hover &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -webkit-transform: rotate(360deg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -moz-transform: rotate(360deg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -ms-transform: rotate(360deg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -transform: rotate(360deg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.site-author-name &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  margin: $site-author-name-margin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  text-align: $site-author-name-align;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  color: $site-author-name-color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  font-weight: $site-author-name-weight;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">.site-description &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  margin-top: $site-description-margin-top;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  text-align: $site-description-align;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  font-size: $site-description-font-size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  color: $site-description-color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>npm install hexo-generator-searchdb –save</p>
<h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><p>next npm install –save hexo-helper-live2d</p>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><h2 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">title: 添加标签页面测试</span></pre></td></tr><tr><td class="code"><pre><span class="line">tags: Test  #添加标签</span></pre></td></tr><tr><td class="code"><pre><span class="line">categories: Test    #添加分类</span></pre></td></tr><tr><td class="code"><pre><span class="line">comments: false</span></pre></td></tr></table></figure>

<h1 id="博客备份"><a href="#博客备份" class="headerlink" title="博客备份"></a>博客备份</h1><p>利用github分支功能进行博客备份，思路说明:</p>
<ul>
<li>master分支：存放博客的静态网页(默认分支)。</li>
<li>hexo分支：存放Hexo博客的源码文件。</li>
</ul>
<h2 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h2><ul>
<li>修改更新博客内容并保存。</li>
<li>执行hexo clean清除本地旧代码。</li>
<li>执行hexo g -d生成静态网站并部署到GitHub的master分支上。</li>
</ul>
<p>进入站点配置文件编辑，搜索deploy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type: git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你的github用户名&#x2F;你的github用户名.github.io.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">  branch: master</span></pre></td></tr></table></figure>

<h2 id="hexo-分支"><a href="#hexo-分支" class="headerlink" title="hexo 分支"></a>hexo 分支</h2><ul>
<li>hexo分支配置hexo分支，该分支为博客源码分支。</li>
<li>使用git clone -b hexo 你的github仓库路径， 拷贝源码仓库。</li>
<li>修改hexo主配置_config.xml的deploy部分配置，设置静态页面的发布分支为master。</li>
<li>添加.gitignore文件，将静态网页的目录及其他无需提交的源文件及目录排除掉。</li>
</ul>
<h3 id="分支设置"><a href="#分支设置" class="headerlink" title="分支设置"></a>分支设置</h3><ul>
<li>hexo分支，该分支为博客源码分支。</li>
<li>使用git clone -b hexo 你的github仓库路径， 拷贝源码仓库。</li>
<li>修改hexo主配置_config.xml的deploy部分配置，设置静态页面的发布分支为master。</li>
<li>添加.gitignore文件，将静态网页的目录及其他无需提交的源文件及目录排除掉。</li>
</ul>
<h3 id="博客源码更新"><a href="#博客源码更新" class="headerlink" title="博客源码更新"></a>博客源码更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout hexo</span></pre></td></tr><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit -m &#39;Code update&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">git push origin hexo</span></pre></td></tr></table></figure>


<h2 id="一键部署脚本"><a href="#一键部署脚本" class="headerlink" title="一键部署脚本"></a>一键部署脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span></pre></td></tr><tr><td class="code"><pre><span class="line">DIR&#x3D;&#96;dirname $0&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Generate blog</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo generate</span></pre></td></tr><tr><td class="code"><pre><span class="line">sleep 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">sleep 5</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Push hexo code</span></pre></td></tr><tr><td class="code"><pre><span class="line">git add .</span></pre></td></tr><tr><td class="code"><pre><span class="line">current_date&#x3D;&#96;date &quot;+%Y-%m-%d %H:%M:%S&quot;&#96;</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit -m &quot;Blog updated: $current_date&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sleep 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">git push origin hexo</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;Finish!&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
